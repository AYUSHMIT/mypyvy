# These types are listed in an order consistent with the stratification graph.
# To remain EPR, there should be no quantifier or function edges from a later sort to an earlier one.
sort round
sort value
sort quorum
sort node

immutable relation le(round, round)

# instantiate total_order(round, le)
axiom le(X,X)
axiom le(X, Y) & le(Y, Z) -> le(X, Z)
axiom le(X, Y) & le(Y, X) -> X = Y
axiom le(X, Y) | le(Y, X)

immutable relation member(node, quorum)
axiom forall Q1, Q2. exists N. member(N, Q1) & member(N, Q2)

mutable relation one_a(round)
mutable relation one_b_never_voted(node, round)
mutable relation one_b_with_max_vote(node, round, round, value)  # first round is "now", second round is max round sender voted in
mutable relation left_round(node, round)
mutable relation proposal(round, value)
mutable relation vote(node, round, value)
mutable relation decision(round, value)

mutable function decision_quorum(round, value): quorum
derived relation choosable(round, value, quorum):
    choosable(R, V, Q) <->
      forall N. member(N, Q) -> !left_round(N, R) | vote(N, R, V)

init !one_a(R)
init !one_b_never_voted(N, R)
init !one_b_with_max_vote(N, R1, R2, V)
init !left_round(N, R)
init !proposal(R, V)
init !vote(N, R, V)
init !decision(R, V)

transition send_1a(r: round)
  modifies one_a
  (forall R. one_a(R) <-> old(one_a(R)) | R = r)

transition join_round_never_voted(n: node, r: round)
  modifies one_b_never_voted, left_round
  old(one_a(r)) &
  !old(left_round(n, r)) &
  (forall R. !le(r, R) -> !old(vote(n, R, V))) &
  (forall N, R. one_b_never_voted(N, R) <-> old(one_b_never_voted(N,R)) | N = n & R = r) &
  (forall N, R. left_round(N, R) <-> old(left_round(N, R)) | N = n & !le(r, R))

transition join_round_with_max_vote(n: node, r: round, maxr: round, v: value)
  modifies one_b_with_max_vote, left_round
  old(one_a(r)) &
  !old(left_round(n, r)) &
  !le(r, maxr) &
  old(vote(n, maxr, v)) &
  (forall R, V. !le(r, R) & old(vote(n, R, V)) -> le(R, maxr)) &
  (forall N, R, MAXR, V.
    one_b_with_max_vote(N, R, MAXR, V) <-> old(one_b_with_max_vote(N,R,MAXR,V)) | N = n & R = r & MAXR = maxr & V = v) &
  (forall N, R. left_round(N, R) <-> old(left_round(N, R)) | N = n & !le(r, R))

transition propose_without_votes(r: round, q: quorum, v: value)
  modifies proposal
  (forall V. !old(proposal(r, V))) &
  (forall N. member(N, q) -> old(one_b_never_voted(N, r))) &
  (forall R, V. proposal(R, V) <-> old(proposal(R, V)) | (R = r & V = v))

transition propose_with_votes(r: round, q: quorum, maxr: round, v: value)
  modifies proposal
  (forall V. !old(proposal(r, V))) &
  # the `exists` on the following line is non-EPR, since we are saying "forall nodes, exists round/value",
  # while we also say:
  #   (decision quorum) "forall rounds/values, exists quorum" and
  #   (quorum intersection axiom) "forall quorum, exists node"
  (forall N. member(N, q) -> old(one_b_never_voted(N, r)) | exists R,V. old(one_b_with_max_vote(N, r, R, V))) &  
  (exists N. member(N, q) & old(one_b_with_max_vote(N, r, maxr, v))) &
  (forall N,MAXR,V. member(N, q) & old(one_b_with_max_vote(N, r, MAXR, V)) -> le(MAXR, maxr)) &
  (forall R, V. proposal(R, V) <-> old(proposal(R, V)) | (R = r & V = v))

transition cast_vote(n: node, v: value, r: round)
  modifies vote
  !old(left_round(n, r)) &
  old(proposal(r, v)) &
  (forall N, R, V. vote(N, R, V) <-> old(vote(N, R, V)) | N = n & R = r & V = v)

transition decide(r: round, v: value, q: quorum)
  modifies decision, decision_quorum
  (forall N. member(N, q) -> old(vote(N, r, v))) &
  (forall R, V. decision(R, V) <-> old(decision(R, V)) | R = r & V = v) &
  (forall R, V.
    !(R = r & V = v) -> decision_quorum(R, V) = old(decision_quorum(R, V))) &
  decision_quorum(r, v) = q

safety
  decision(R1, V1) & decision(R2, V2) -> V1 = V2
 
invariant proposal(R,V1) & proposal(R,V2) -> V1 = V2
invariant vote(N,R,V) -> proposal(R,V)
invariant one_b_never_voted(N,R2) & !le(R2,R1) -> left_round(N,R1)
invariant one_b_never_voted(N,R1) & !le(R1,R2) -> !vote(N, R2, V)
invariant one_b_with_max_vote(N,R2,R3,V3) & !le(R2,R1) -> left_round(N,R1)
invariant one_b_with_max_vote(N,R1,R2,V2) & vote(N,R3,V3) & !le(R1,R3) -> le(R3, R2)
invariant one_b_with_max_vote(N,R1,R2,V2) -> vote(N, R2, V2) & !le(R1, R2)

invariant
  forall R1, V1, R2, V2, Q.
    choosable(R1, V1, Q) ->
    !le(R2, R1) &
    proposal(R2, V2) ->
    V1 = V2

invariant
  forall R, V.
    decision(R, V) ->
    forall N. member(N, decision_quorum(R, V)) -> vote(N, R, V)


