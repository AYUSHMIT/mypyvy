from typing import List, Optional, Any, Union

class CheckSatResult: ...

sat: CheckSatResult
unsat: CheckSatResult

class Z3PPObject: ...
class Context: ...
class ModelRef(Z3PPObject): ...

class Solver(Z3PPObject):
#    def __setattr__(self, name: str, value: Any) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exn_type: Any, exn_value: Any, traceback: Any) -> None: ...
    def add(self, *args: ExprRef) -> None: ...
    def check(self) -> CheckSatResult: ...
    def model(self) -> ModelRef: ...
    def to_smt2(self) -> str: ...


class AstRef(Z3PPObject): ...
class SortRef(AstRef): ...
class ExprRef(AstRef):
      def __eq__(self, other: ExprRef) -> ExprRef: ... # type: ignore
      def __ne__(self, other: ExprRef) -> ExprRef: ... # type: ignore
      def sort(self) -> SortRef: ...

class FuncDeclRef(AstRef):
      def __call__(self, *args: ExprRef) -> ExprRef: ...
      def arity(self) -> int: ...
      def domain(self, i: int) -> SortRef: ...
      def range(self) -> SortRef: ...


def Function(name: str, *args: SortRef) -> FuncDeclRef: ...
def Const(name: str, sort: SortRef) -> ExprRef: ...
def Consts(names: str, sort: SortRef) -> List[ExprRef]: ...
def DeclareSort(name: str, ctx: Optional[Context] = ...) -> SortRef: ...
def BoolSort(ctx: Optional[Context] = ...) -> SortRef: ...

def Not(arg: ExprRef) -> ExprRef: ...
def And(*args: ExprRef) -> ExprRef: ...
def Or(*args: ExprRef) -> ExprRef: ...
def Implies(a: ExprRef, b: ExprRef) -> ExprRef: ...

def BoolVal(x: bool) -> ExprRef: ...

def ForAll(vs: Union[ExprRef, List[ExprRef]], body: ExprRef) -> ExprRef: ...
def Forall(vs: Union[ExprRef, List[ExprRef]], body: ExprRef) -> ExprRef: ...
def Exists(vs: Union[ExprRef, List[ExprRef]], body: ExprRef) -> ExprRef: ...


def main_ctx() -> Context: ...

def init(path: str) -> None: ...